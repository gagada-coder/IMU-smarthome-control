#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <ESP8266WiFi.h>
#include <WiFiUdp.h>

const char *STAssid ="zhu";               //需要连接路由器的名称
const char *STApassword="12345678";  //路由器的密码
/****************UDP设置项 *****************/
unsigned int read_Port = 41002;           //监听端口
unsigned int send_Port = 6565;           //发送端口
char readdata[512];                       //数据缓存
WiFiUDP Udp;                              //定义udp对象


Adafruit_MPU6050 mpu;

#define scl 0  //D0
#define sda 2   //D1

 
unsigned long now, lastTime = 0;
float dt;                                   //微分时间
 
int16_t ax, ay, az, gx, gy, gz;             //加速度计陀螺仪原始数据
float aax=0, aay=0,aaz=0, agx=0, agy=0, agz=0, agy_last=0;    //角度变量
long axo = 0, ayo = 0, azo = 0;             //加速度计偏移量
long gxo = 0, gyo = 0, gzo = 0;             //陀螺仪偏移量
sensors_event_t a, g, temp;//参数

float pi = 3.1415926;
 
uint8_t n_sample = 8;                       //加速度计滤波算法采样个数
float aaxs[8] = {0}, aays[8] = {0}, aazs[8] = {0};         //x,y轴采样队列
long aax_sum, aay_sum,aaz_sum;                      //x,y轴采样和
 
float a_x[10]={0}, a_y[10]={0},a_z[10]={0} ,g_x[10]={0} ,g_y[10]={0},g_z[10]={0}; //加速度计协方差计算队列
float Px=1, Rx, Kx, Sx, Vx, Qx;             //x轴卡尔曼变量
float Py=1, Ry, Ky, Sy, Vy, Qy;             //y轴卡尔曼变量
float Pz=1, Rz, Kz, Sz, Vz, Qz;             //z轴卡尔曼变量
 
void setup()
{
  Wire.begin(sda,scl);//IIC初始化
  Serial.begin(115200);//串口初始化
 
  if (!mpu.begin()) {
    Serial.println("Sensor init failed");
    while (1)
      yield();
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_16_G);
  mpu.setGyroRange(MPU6050_RANGE_250_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  Serial.println("Found a MPU-6050 sensor"); //初始化MPU6050
 
  unsigned short times = 100;             //采样次数

  
    for(int i=0;i<times;i++)
    {
      mpu.getEvent(&a, &g, &temp); //读取六轴原始数值
      axo += a.acceleration.x; ayo += a.acceleration.y; azo += a.acceleration.x;      //采样和
      gxo += g.gyro.x; gyo += g.gyro.y; gzo += g.gyro.z;
    
    }
    
    axo /= times; ayo /= times; azo /= times; //计算加速度计偏移
    gxo /= times; gyo /= times; gzo /= times; //计算陀螺仪偏移

  WiFi.mode(WIFI_STA);                    //设置为STA模式
  WiFi.begin(STAssid, STApassword);       //配置连接信息，开始连接
  gotoWifi();                             //等待连接路由器
  Serial.println("连接路由器成功");
  Udp.begin(read_Port);                   //UDP设置监听指定端口
}
 
void loop()
{
    unsigned long now = millis();             //当前时间(ms)
    dt = (now - lastTime) / 1000.0;           //微分时间(s)
    lastTime = now;                           //上一次采样时间(ms)

    if (WiFi.status() != WL_CONNECTED) { 
    WiFi.disconnect();
    WiFi.begin(STAssid, STApassword);
    gotoWifi();  
  }
  else{
    mpu.getEvent(&a, &g, &temp);//读取六轴原始数值
 
    aax = atan(a.acceleration.y / a.acceleration.z) * (-180) / pi;    //y轴对于z轴的夹角
    aay = atan(a.acceleration.x / a.acceleration.z) * 180 / pi;       //x轴对于z轴的夹角
    aaz = atan(a.acceleration.z / a.acceleration.y) * 180 / pi;       //z轴对于y轴的夹角
 
    aax_sum = 0;                              // 对于加速度计原始数据的滑动加权滤波算法
    aay_sum = 0;
    aaz_sum = 0;
  
    for(int i=1;i<n_sample;i++)
    {
        aaxs[i-1] = aaxs[i];
        aax_sum += aaxs[i] * i;
        aays[i-1] = aays[i];
        aay_sum += aays[i] * i;
        aazs[i-1] = aazs[i];
        aaz_sum += aazs[i] * i;
    }
    
    aaxs[n_sample-1] = aax;
    aax_sum += aax * n_sample;
    aax = (aax_sum / (11*n_sample/2.0)) * 9 / 7.0; //角度限幅至0-90°
    aays[n_sample-1] = aay;                        
    aay_sum += aay * n_sample;                    
    aay = (aay_sum / (11*n_sample/2.0)) * 9 / 7.0;
    aazs[n_sample-1] = aaz; 
    aaz_sum += aaz * n_sample;
    aaz = (aaz_sum / (11*n_sample/2.0)) * 9 / 7.0;
 
    float gyrox = - (g.gyro.x-gxo) * dt; //x轴角速度
    float gyroy = - (g.gyro.y-gyo) * dt; //y轴角速度
    float gyroz = - (g.gyro.z-gzo) * dt; //z轴角速度
    agx += gyrox;                             //x轴角速度积分
    agy += gyroy;                             //x轴角速度积分
    agz += gyroz;
    
    /* kalman start */
    Sx = 0; Rx = 0;
    Sy = 0; Ry = 0;
    Sz = 0; Rz = 0;
    
    for(int i=1;i<10;i++)
    {                 //测量值平均值运算
        a_x[i-1] = a_x[i];                      //即加速度平均值
        Sx += a_x[i];
        a_y[i-1] = a_y[i];
        Sy += a_y[i];
        a_z[i-1] = a_z[i];
        Sz += a_z[i];
    
    }
    a_x[9] = aax;
    Sx += aax;
    Sx /= 10;                                 //x轴加速度平均值
    a_y[9] = aay;
    Sy += aay;
    Sy /= 10;                                 //y轴加速度平均值
    a_z[9] = aaz;
    Sz += aaz;
    Sz /= 10;
 
    for(int i=0;i<10;i++)
    {
        Rx += sq(a_x[i] - Sx);
        Ry += sq(a_y[i] - Sy);
        Rz += sq(a_z[i] - Sz);
    
    }
    
    Rx = Rx / 9;                              //得到方差
    Ry = Ry / 9;                        
    Rz = Rz / 9;
  
    Px = Px + 0.0025;                        
    Kx = Px / (Px + Rx);                      //计算卡尔曼增益
    agx = agx + Kx * (aax - agx);             //陀螺仪角度与加速度计速度叠加
    Px = (1 - Kx) * Px;                       //更新p值
 
    Py = Py + 0.0025;
    Ky = Py / (Py + Ry);
    agy = agy + Ky * (aay - agy); 
    Py = (1 - Ky) * Py;
  
    Pz = Pz + 0.0025;
    Kz = Pz / (Pz + Rz);
    agz = agz + Kz * (aaz - agz); 
    Pz = (1 - Kz) * Pz;
 
    /* kalman end */
 
    Serial.print(agx);Serial.print(",");
    Serial.print(agy);Serial.print(",");
    Serial.print(agz);Serial.println();
    data_process(agx,agy,agz);//数据处理
    delay(10);
    
  }  
    
}


void gotoWifi(){
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);    
    Serial.print(".");
  }
  Serial.println("");
}
*将接收的数据，以String类型返回，方便分析处理
String Read_Udp(){
  String data="";
  int packetSize = Udp.parsePacket();
  if (packetSize) {
    memset(readdata,0x00,sizeof(readdata));
    Udp.read(readdata, 511);
    Udp.flush();
    for(int i=0;i<packetSize;i++){
      data +=readdata[i];
    }
    Serial.println(data);   
    myPrint("收到",1); 
  }
  return data;
}
*第一个参数，使用String类型作为发送内容
*第二个参数，a为真，指定发送，对发送方返回数据，a为假，广播发送，群发信息
*/
void myPrint(String data,bool a){
  if(a){
    Udp.beginPacket("192.168.137.131",41000);//数据发送，目标IP地址与端口
  }else{
    Udp.beginPacket("", send_Port);
  }  
  Udp.print(data);
  Udp.endPacket();
}

//////////////大数据分析
from cProfile import label
import imp
from lib2to3.pgen2.pgen import DFAState
from math import frexp
from pyexpat import features
from re import T
from tkinter.tix import COLUMN
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler,StandardScaler   #特征处理方法
from sklearn.preprocessing import LabelEncoder,OneHotEncoder
from sklearn.preprocessing import Normalizer
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis #LDA降维
from sklearn.decomposition import PCA
import os
import pydotplus
os.environ["PATH"]+=os.pathsep+"D:/000BISHE/Graphviz/bin"
import seaborn as sns
import matplotlib.pyplot as plt

#bdu：BlutdruckU----False:MinMaxScaler,True:StandardScaler
#bdd：BlutdruckD----False:MinMaxScaler,True:StandardScaler
#glu：GLU----False:MinMaxScaler,True:StandardScaler
#hg：height----False:MinMaxScaler,True:StandardScaler
#wg：weight----False:MinMaxScaler,True:StandardScaler
#wai：waistline----False:MinMaxScaler,True:StandardScaler
#hrt：heartrate----False:MinMaxScaler,True:StandardScaler
#age：age----False:MinMaxScaler,True:StandardScaler
#hgb：HGB----False:MinMaxScaler,True:StandardScaler
#wbc：WBC----False:MinMaxScaler,True:StandardScaler
#plt：PLT----False:MinMaxScaler,True:StandardScaler
#tcho：TCHO----False:MinMaxScaler,True:StandardScaler
#tg：TG----False:MinMaxScaler,True:StandardScaler
#ldl：LDL----False:MinMaxScaler,True:StandardScaler
#hdl：HDL----False:MinMaxScaler,True:StandardScaler
def hand_preprocessing(bdu=False,bdd=False,glu=False,hg=False,wg=False,wai=False,mai=False,tcho=False,tg=False,ldl=False,lower_d=False,ld_n=1,wbc=False,plt=False,hrt=False):
    df=pd.read_csv("C:/Users/LEGION/Desktop/date/date/health2.csv")
    #1.清洗数据
    df=df.dropna(subset=["HIGN","LOW","LEFT","RIGHT","MEDIUM","TG","LDL","HDL"]) #去掉空值
    #2.得到标注
    label=df["MEDIUM"]
    df=df.drop("MEDIUM",axis=1)
    #3.特征选择
    df=df.drop(['id','HIGN','LOW'], axis=1)
    #4.特征处理
    scaler_lst=[bdu,bdd,glu,hg,wg,wai,mai,tcho,tg,ldl,wbc,plt,hrt]
column_lst=["HIGN","LOW","LEFT","RIGHT","MEDIUM","TG","LDL","HDL"]
    for i in range(len(scaler_lst)):               #遍历scaler_lst
        if not scaler_lst[i]:                      #当它表示的值不为真时
           df[column_lst[i]]=MinMaxScaler().fit_transform(df[column_lst[i]].values.reshape(-1,1)).reshape(1,-1)[0]                     #将df中的值进行转换，-1,1转化成列的格式，1，-1再变回来，因为是二维的向量，所以选第0个
  else:
            df[column_lst[i]]=\
                StandardScaler().fit_transform(df[column_lst[i]].values.reshape(-1,1)).reshape(1,-1)[0]
    if lower_d:






